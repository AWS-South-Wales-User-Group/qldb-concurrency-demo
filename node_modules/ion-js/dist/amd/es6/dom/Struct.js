define(["require", "exports", "../Ion", "./FromJsConstructor", "./Value"], function (require, exports, Ion_1, FromJsConstructor_1, Value_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Struct = void 0;
    class Struct extends Value_1.Value(Object, Ion_1.IonTypes.STRUCT, FromJsConstructor_1.FromJsConstructor.NONE) {
        constructor(fields, annotations = []) {
            super();
            this._fields = Object.create(null);
            for (const [fieldName, fieldValue] of fields) {
                this._fields[fieldName] = fieldValue;
            }
            this._setAnnotations(annotations);
            return new Proxy(this, {
                set: function (target, name, value) {
                    target._fields[name] = value;
                    return true;
                },
                get: function (target, name) {
                    if (name in target) {
                        return target[name];
                    }
                    return target._fields[name];
                },
                deleteProperty: function (target, name) {
                    if (name in target._fields) {
                        delete target._fields[name];
                    }
                    return true;
                },
            });
        }
        get(...pathElements) {
            if (pathElements.length === 0) {
                throw new Error("Value#get requires at least one parameter.");
            }
            const [pathHead, ...pathTail] = pathElements;
            if (typeof pathHead !== "string") {
                throw new Error(`Cannot index into a struct with a ${typeof pathHead}.`);
            }
            const child = this._fields[pathHead];
            if (child === undefined) {
                return null;
            }
            if (pathTail.length === 0) {
                return child;
            }
            return child.get(...pathTail);
        }
        fieldNames() {
            return Object.keys(this._fields);
        }
        fields() {
            return Object.entries(this._fields);
        }
        elements() {
            return Object.values(this._fields);
        }
        [Symbol.iterator]() {
            return this.fields()[Symbol.iterator]();
        }
        toString() {
            return ("{" +
                [...this.fields()]
                    .map(([name, value]) => name + ": " + value)
                    .join(", ") +
                "}");
        }
        writeTo(writer) {
            writer.setAnnotations(this.getAnnotations());
            writer.stepIn(Ion_1.IonTypes.STRUCT);
            for (const [fieldName, value] of this) {
                writer.writeFieldName(fieldName);
                value.writeTo(writer);
            }
            writer.stepOut();
        }
        deleteField(name) {
            if (name in this._fields) {
                delete this._fields[name];
                return true;
            }
            return false;
        }
        toJSON() {
            return this._fields;
        }
        static _fromJsValue(jsValue, annotations) {
            if (!(jsValue instanceof Object)) {
                throw new Error(`Cannot create a dom.Struct from: ${jsValue.toString()}`);
            }
            const fields = Object.entries(jsValue).map(([key, value]) => [key, Value_1.Value.from(value)]);
            return new this(fields, annotations);
        }
    }
    exports.Struct = Struct;
});
//# sourceMappingURL=Struct.js.map