"use strict";
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QldbSession = void 0;
const Errors_1 = require("./errors/Errors");
const LogUtil_1 = require("./LogUtil");
const Result_1 = require("./Result");
const ResultReadable_1 = require("./ResultReadable");
const Transaction_1 = require("./Transaction");
const TransactionExecutor_1 = require("./TransactionExecutor");
class QldbSession {
    constructor(communicator) {
        this._communicator = communicator;
        this._isClosed = false;
    }
    endSession() {
        if (this._isClosed) {
            return;
        }
        this._isClosed = true;
        this._communicator.endSession();
    }
    closeSession() {
        this._isClosed = true;
    }
    executeLambda(transactionLambda, retryConfig, executionContext) {
        return __awaiter(this, void 0, void 0, function* () {
            let transaction;
            while (true) {
                transaction = null;
                try {
                    transaction = yield this.startTransaction();
                    const transactionExecutor = new TransactionExecutor_1.TransactionExecutor(transaction);
                    let returnedValue = yield transactionLambda(transactionExecutor);
                    if (returnedValue instanceof ResultReadable_1.ResultReadable) {
                        returnedValue = yield Result_1.Result.bufferResultReadable(returnedValue);
                    }
                    yield transaction.commit();
                    return returnedValue;
                }
                catch (e) {
                    executionContext.setLastException(e);
                    if (Errors_1.isInvalidSessionException(e)) {
                        this.closeSession();
                        throw e;
                    }
                    if (!Errors_1.isOccConflictException(e)) {
                        this._noThrowAbort(transaction);
                    }
                    if (executionContext.getExecutionAttempt() >= retryConfig.getRetryLimit()) {
                        throw e;
                    }
                    if (e instanceof Errors_1.StartTransactionError || Errors_1.isRetriableException(e) || Errors_1.isOccConflictException(e)) {
                        LogUtil_1.warn(`OCC conflict or retriable exception occurred: ${e}.`);
                    }
                    else {
                        throw e;
                    }
                }
                executionContext.incrementExecutionAttempt();
                yield this._retrySleep(executionContext, retryConfig, transaction);
            }
        });
    }
    getSessionToken() {
        return this._communicator.getSessionToken();
    }
    isSessionOpen() {
        return !this._isClosed;
    }
    startTransaction() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const startTransactionResult = yield this._communicator.startTransaction();
                const transaction = new Transaction_1.Transaction(this._communicator, startTransactionResult.TransactionId);
                return transaction;
            }
            catch (e) {
                if (Errors_1.isBadRequestException(e)) {
                    throw new Errors_1.StartTransactionError(e);
                }
                throw e;
            }
        });
    }
    _noThrowAbort(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (null == transaction) {
                    this._communicator.abortTransaction();
                }
                else {
                    yield transaction.abort();
                }
            }
            catch (e) {
                LogUtil_1.warn(`Ignored error while aborting transaction during execution: ${e}.`);
            }
        });
    }
    _retrySleep(executionContext, retryConfig, transaction) {
        let transactionId = (transaction != null) ? transaction.getTransactionId() : null;
        const backoffFunction = retryConfig.getBackoffFunction();
        let backoffDelay = backoffFunction(executionContext.getExecutionAttempt(), executionContext.getLastException(), transactionId);
        if (backoffDelay == null || backoffDelay < 0) {
            backoffDelay = 0;
        }
        return this._sleep(backoffDelay);
    }
    _sleep(sleepTime) {
        return new Promise(resolve => setTimeout(resolve, sleepTime));
    }
}
exports.QldbSession = QldbSession;
